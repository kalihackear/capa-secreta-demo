<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>CryptoChat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    :root {
      color-scheme: light;
      --bg: radial-gradient(circle at top, #e5e7eb 0, #f9fafb 45%, #e5e7eb 100%);
      --layer: #f9fafb;
      --card: #ffffff;
      --card-soft: #f3f4f6;
      --nav-grad: linear-gradient(135deg, rgba(248, 250, 252, 0.82), rgba(226, 232, 240, 0.5));
      --top-blur-bg: rgba(248, 250, 252, 0.86);
      --accent: #1d9bf0;
      --accent-soft: rgba(37, 99, 235, 0.12);
      --accent-strong: #2563eb;
      --border: #d1d5db;
      --text: #0f172a;
      --muted: #6b7280;
      --danger: #dc2626;
      --success: #16a34a;
      --shadow-strong: 0 12px 30px rgba(15, 23, 42, 0.18);
      --shadow-soft: 0 8px 18px rgba(15, 23, 42, 0.14);
    }

    body.dark {
      color-scheme: dark;
      --bg: radial-gradient(circle at top, #020617 0, #020617 45%, #000 100%);
      --layer: #020617;
      --card: #050814;
      --card-soft: #111827;
      --nav-grad: linear-gradient(135deg, rgba(15, 23, 42, 0.55), rgba(15, 23, 42, 0.18));
      --top-blur-bg: rgba(15, 23, 42, 0.72);
      --accent: #2294ff;
      --accent-soft: rgba(56, 189, 248, 0.16);
      --accent-strong: #22d3ee;
      --border: #1f2937;
      --text: #f9fafb;
      --muted: #9ca3af;
      --danger: #f97373;
      --success: #4ade80;
      --shadow-strong: 0 18px 40px rgba(0, 0, 0, 0.9);
      --shadow-soft: 0 10px 22px rgba(0, 0, 0, 0.7);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .hidden { display: none !important; }

    .app {
      max-width: 640px;
      width: 100%;
      min-height: 100vh;
      padding: 6px 10px 120px;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    .app.chat-open { padding-bottom: 16px; }

    /* Barra superior translúcida */
    .top-bar {
      padding: 4px 0 4px;
      display: flex;
      justify-content: center;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 5;
    }
    .top-bar-inner {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 4px 14px;
      border-radius: 999px;
      background: var(--top-blur-bg);
      border: 1px solid rgba(148, 163, 184, 0.45);
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(16px) saturate(140%);
    }
    .top-pill {
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 4px 8px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent-strong);
    }

    /* Vistas genéricas */
    .app-main { flex: 1; display: flex; flex-direction: column; gap: 10px; margin-top: 4px; min-height: 0; }
    .view-panel { display: none; }
    .view-panel.active { display: block; }
    .view-header { display: flex; align-items: center; justify-content: space-between; padding: 4px 2px 6px; }
    .view-title { font-size: 1.2rem; font-weight: 600; display: flex; align-items: center; gap: 2px; min-height: 1.2em; }
    .view-left, .view-right { display: flex; align-items: center; gap: 6px; min-width: 60px; }
    .text-link-btn { border: none; background: transparent; color: var(--accent); font-size: 0.9rem; padding: 2px 6px; cursor: pointer; }
    .icon-button { border: none; border-radius: 999px; background: var(--card-soft); color: var(--text); padding: 5px 7px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: var(--shadow-soft); }
    .icon-button svg { width: 18px; height: 18px; }
    .icon-button.locked { color: var(--accent-strong); }

    .btn { display: inline-flex; align-items: center; justify-content: center; gap: 6px; padding: 8px 14px; border-radius: 999px; border: 1px solid transparent; font-size: 0.9rem; cursor: pointer; background: linear-gradient(135deg, var(--accent), var(--accent-strong)); color: #fff; box-shadow: 0 10px 20px rgba(37, 99, 235, 0.4); transition: transform 0.08s ease, box-shadow 0.08s ease; white-space: nowrap; }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 14px 26px rgba(30, 64, 175, 0.6); }
    .btn.secondary { background: var(--card-soft); border-color: var(--border); color: var(--text); box-shadow: none; }
    .btn.small { font-size: 0.8rem; padding: 6px 10px; }
    .buttons-row { display: flex; flex-wrap: wrap; gap: 8px; margin: 6px 0 4px; }

    .card { background: var(--card); border-radius: 16px; border: 1px solid var(--border); padding: 10px 12px; box-shadow: var(--shadow-strong); margin-bottom: 8px; }
    .field { margin-bottom: 10px; }
    .field label { display: block; font-size: 0.85rem; margin-bottom: 4px; }
    input[type="text"], input[type="password"], textarea {
      width: 100%; border-radius: 10px; border: 1px solid var(--border); background: var(--card-soft); color: var(--text);
      padding: 8px 10px; font-size: 0.9rem; resize: vertical; min-height: 36px;
    }
    input::placeholder, textarea::placeholder { color: var(--muted); }
    textarea { min-height: 70px; line-height: 1.35; }

    /* Bottom nav efecto cristal */
    .bottom-nav { position: fixed; left: 50%; transform: translateX(-50%); bottom: 28px; width: 100%; max-width: 640px; z-index: 20; pointer-events: none; }
    .bottom-nav-inner {
      pointer-events: auto; margin: 0 14px; padding: 6px 14px; border-radius: 999px;
      background: var(--nav-grad); backdrop-filter: blur(24px) saturate(150%);
      border: 1px solid rgba(255,255,255,0.18); box-shadow: 0 18px 42px rgba(15,23,42,0.7);
      display: flex; align-items: center; justify-content: space-between; gap: 6px;
    }
    body.dark .bottom-nav-inner { box-shadow: 0 12px 30px rgba(15,23,42,0.2); border-color: rgba(148,163,184,0.7); }
    .nav-item { flex: 1; border: none; border-radius: 999px; background: transparent; color: var(--muted); font-size: 0.75rem; padding: 6px 4px 4px; display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 2px; cursor: pointer; transition: background 0.12s ease, color 0.12s ease, transform 0.08s ease; }
    .nav-item svg { width: 18px; height: 18px; }
    .nav-item.active { background: rgba(255,255,255,0.9); color: #111827; transform: translateY(-1px); }
    body.dark .nav-item.active { background: rgba(248,250,252,0.06); color: #f9fafb; }
    .nav-item:not(.active):hover { background: rgba(255,255,255,0.5); color: var(--text); }
    body.dark .nav-item:not(.active):hover { background: rgba(15,23,42,0.25); }

    /* Lista de chats */
    .chat-list-panel { background: var(--card); border-radius: 16px; border: 1px solid var(--border); padding: 0; box-shadow: var(--shadow-strong); max-height: 460px; overflow: hidden; display: flex; flex-direction: column; }
    .chat-search-wrapper { padding: 6px 8px 4px; background: var(--card); border-bottom: 1px solid var(--border); position: sticky; top: 0; z-index: 2; }
    .chat-search-input { width: 100%; border-radius: 999px; border: 1px solid var(--border); background: var(--card-soft); color: var(--text); padding: 6px 10px; font-size: 0.85rem; }
    .chat-list { padding: 4px 4px 6px; display: flex; flex-direction: column; gap: 3px; overflow-y: auto; flex: 1; }
    .chat-row { border: none; background: transparent; padding: 6px 8px; width: 100%; display: flex; align-items: center; gap: 10px; cursor: pointer; border-radius: 12px; transition: background 0.08s ease; }
    .chat-row:hover { background: rgba(229,231,235,0.9); }
    body.dark .chat-row:hover { background: rgba(31,41,55,0.7); }
    .chat-row.active { background: var(--accent-soft); }
    .chat-select-circle { width: 20px; height: 20px; border-radius: 999px; border: 2px solid var(--border); display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .chat-select-circle-inner { width: 10px; height: 10px; border-radius: 999px; background: transparent; }
    .chat-select-circle.selected { border-color: var(--accent-strong); background: rgba(37,99,235,0.18); }
    .chat-select-circle.selected .chat-select-circle-inner { background: var(--accent-strong); }
    .chat-avatar { width: 38px; height: 38px; border-radius: 999px; background: radial-gradient(circle at top, #4f46e5, #0ea5e9); display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.95rem; color: #f9fafb; flex-shrink: 0; }
    body.dark .chat-avatar { background: radial-gradient(circle at top, #4f46e5, #1f2937); }
    .chat-row-body { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 2px; }
    .chat-row-top { display: flex; align-items: center; justify-content: space-between; gap: 6px; }
    .chat-row-name { font-size: 0.9rem; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .chat-row-time { font-size: 0.75rem; color: var(--muted); flex-shrink: 0; }
    .chat-row-bottom { display: flex; align-items: center; justify-content: space-between; gap: 6px; }
    .chat-row-preview { font-size: 0.8rem; color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .chat-row-right { display: flex; align-items: center; gap: 6px; }
    .chat-row-badge { font-size: 0.7rem; padding: 1px 6px; border-radius: 999px; border: 1px solid var(--border); color: var(--muted); flex-shrink: 0; }
    .lock-toggle-btn { border: none; background: transparent; color: var(--muted); padding: 2px; border-radius: 999px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; }
    .lock-toggle-btn svg { width: 16px; height: 16px; }
    .lock-toggle-btn.active { color: var(--accent-strong); }

    /* Chat detalle estilo mensajería */
    .chat-main { background: var(--card); border-radius: 16px; border: 1px solid var(--border); padding: 8px 6px 8px; display: flex; flex-direction: column; gap: 8px; box-shadow: var(--shadow-strong); flex: 1; min-height: 0; }
    .chat-messages { flex: 1; min-height: 0; overflow-y: auto; border-radius: 14px; padding: 6px 6px 4px; background: var(--layer); border: none; font-size: 0.9rem; }
    body.dark .chat-messages { background: #0b1220; }
    .message { margin-bottom: 6px; max-width: 80%; padding: 7px 10px; border-radius: 18px; cursor: pointer; }
    .message.me { margin-left: auto; background: #1d9bf0; color: #f9fafb; border-bottom-right-radius: 4px; }
    .message.other { margin-right: auto; background: #e5e7eb; color: #111827; border-bottom-left-radius: 4px; }
    body.dark .message.other { background: #374151; color: #f9fafb; }
    .message-meta { font-size: 0.7rem; opacity: 0.9; margin-top: 2px; text-align: right; }

    .chat-input { margin-top: 2px; }
    .chat-input-bar { display: flex; align-items: flex-end; gap: 8px; padding: 6px 8px; border-radius: 999px; background: var(--card-soft); border: 1px solid var(--border); }
    .chat-input-bar textarea { flex: 1; border: none; background: transparent; padding: 4px 6px; resize: none; min-height: 32px; max-height: 90px; font-size: 0.9rem; }
    .chat-input-bar textarea:focus { outline: none; }
    .chat-send-btn { border: none; border-radius: 999px; background: linear-gradient(135deg, var(--accent), var(--accent-strong)); color: #fff; padding: 7px 9px; display: inline-flex; align-items: center; justify-content: center; box-shadow: 0 8px 18px rgba(37, 99, 235, 0.45); cursor: pointer; flex-shrink: 0; }
    .chat-send-btn svg { width: 18px; height: 18px; }
    .chat-send-btn:disabled { opacity: .5; box-shadow: none; cursor: default; }

    /* Manual */
    .manual-card { margin-top: 4px; }
    .manual-divider { height: 1px; width: 100%; background: var(--border); opacity: .7; margin: 10px 0; }
    .password-wrapper { position: relative; display: flex; align-items: center; }
    .password-wrapper input { padding-right: 34px; }
    .password-toggle-btn { position: absolute; right: 8px; border: none; background: transparent; cursor: pointer; color: var(--muted); padding: 2px; display: inline-flex; align-items: center; justify-content: center; }
    .password-toggle-btn svg { width: 16px; height: 16px; }

    /* Ajustes */
    .settings-group { background: var(--card); border-radius: 16px; border: 1px solid var(--border); box-shadow: var(--shadow-strong); overflow: hidden; margin-bottom: 10px; }
    .settings-row { display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-bottom: 1px solid rgba(148,163,184,0.2); }
    .settings-row:last-child { border-bottom: none; }
    .settings-icon { width: 32px; height: 32px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0; color: #f9fafb; }
    .settings-icon svg { width: 18px; height: 18px; }
    .settings-icon.blue { background: #3b82f6; }
    .settings-icon.green { background: #22c55e; }
    .settings-icon.orange { background: #f97316; }
    .settings-icon.gray { background: #6b7280; }
    .settings-body { flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 2px; }
    .settings-title { font-size: 0.9rem; font-weight: 500; }
    .settings-sub { font-size: 0.8rem; color: var(--muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .settings-actions { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 4px; }
    .settings-actions .btn { font-size: 0.75rem; padding: 5px 9px; }
    .settings-status { padding: 6px 10px 8px; font-size: 0.8rem; color: var(--muted); }

    /* Modal mejorado: soporta varios bloques copiables y choices */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; z-index: 30; backdrop-filter: blur(6px); }
    .modal-card { max-width: 380px; width: calc(100% - 40px); background: var(--card); border-radius: 18px; border: 1px solid var(--border); box-shadow: var(--shadow-strong); padding: 12px 14px 10px; }
    .modal-title { font-size: 1rem; font-weight: 600; margin-bottom: 4px; }
    .modal-message { font-size: 0.85rem; color: var(--muted); margin-bottom: 8px; white-space: pre-wrap; word-break: break-word; overflow-wrap: anywhere; }
    .modal-keys { display: flex; flex-direction: column; gap: 8px; margin-bottom: 6px; }
    .modal-kv-label { font-size: .75rem; color: var(--muted); margin: 2px 0 4px; }
    .modal-key-wrapper { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .modal-key-text {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.8rem; word-break: break-all; overflow-wrap: anywhere;
      padding: 8px 10px; background: var(--card-soft); border: 1px solid var(--border); border-radius: 10px; flex: 1; max-height: 120px; overflow: auto;
    }
    .modal-buttons { display: flex; justify-content: flex-end; gap: 8px; margin-top: 4px; }
    .modal-buttons .btn { font-size: 0.8rem; padding: 6px 11px; }
    .modal-choice-list { display: flex; flex-direction: column; gap: 8px; margin-top: 6px; }

    /* Toast */
    .toast { position: fixed; bottom: 96px; left: 50%; transform: translateX(-50%); padding: 6px 12px; border-radius: 999px; background: rgba(15, 23, 42, 0.96); border: 1px solid var(--border); color: #f9fafb; font-size: 0.8rem; box-shadow: var(--shadow-soft); z-index: 25; opacity: 0; pointer-events: none; transition: opacity .2s ease, transform .2s ease; }
    .toast.visible { opacity: 1; transform: translateX(-50%) translateY(-4px); }
    .toast.ok { border-color: var(--success); }
    .toast.error { border-color: var(--danger); }
    body.dark .toast { background: rgba(15,23,42,0.96); color: #f9fafb; }

    @media (max-width: 600px) {
      .chat-list-panel { max-height: calc(100vh - 210px); }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="top-bar">
      <div class="top-bar-inner">
        <div class="top-pill">CRYPTOCHAT</div>
      </div>
    </header>

    <main class="app-main">
      <!-- CHATS -->
      <section id="view-chats" class="view-panel active">
        <div id="chatsListContainer">
          <div class="view-header">
            <div class="view-left">
              <button class="text-link-btn" type="button" id="chatsEditBtn">Editar</button>
            </div>
            <div class="view-title" id="chatsTitleLabel">Chats</div>
            <div class="view-right">
              <button class="icon-button" type="button" id="chatsSearchBtn" aria-label="Buscar">
                <svg viewBox="0 0 24 24" fill="none"><circle cx="11" cy="11" r="5.5" stroke="currentColor" stroke-width="1.6"/><path d="M15.5 15.5 19 19" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
              </button>
              <button class="icon-button" type="button" id="joinChatBtn" aria-label="Unirse a chat">
                <svg viewBox="0 0 24 24" fill="none"><path d="M9 8a3 3 0 0 1 3-3h2a3 3 0 1 1 0 6h-1.5" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><path d="M15 16a3 3 0 0 1-3 3H10a3 3 0 1 1 0-6h1.5" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
              </button>
              <button class="icon-button" type="button" id="newChatBtn" aria-label="Nuevo chat">
                <svg viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
              </button>
              <button class="text-link-btn hidden" type="button" id="chatsDeleteSelectedBtn">Eliminar</button>
              <button class="text-link-btn hidden" type="button" id="chatsEncryptSelectedBtn">Bloquear</button>
            </div>
          </div>

          <div class="chat-list-panel">
            <div class="chat-search-wrapper">
              <input id="chatSearchInput" class="chat-search-input" type="text" placeholder="Buscar por nombre de chat" />
            </div>
            <div id="chatList" class="chat-list"></div>
          </div>
        </div>

        <!-- Detalle de chat -->
        <div id="chatDetailContainer" class="hidden">
          <div class="view-header">
            <div class="view-left">
              <button class="icon-button" type="button" id="chatBackBtn" aria-label="Volver">
                <svg viewBox="0 0 24 24" fill="none"><path d="M15 5 9 12l6 7" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
              </button>
            </div>
            <div class="view-title">
              <div id="chatTitle">Chat</div>
            </div>
            <div class="view-right">
              <button class="icon-button" type="button" id="chatMenuBtn" aria-label="Cifrado privado">
                <svg viewBox="0 0 24 24" fill="none"><path d="M8 10V8a4 4 0 1 1 8 0v2" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><rect x="6" y="10" width="12" height="10" rx="2" stroke="currentColor" stroke-width="1.6"/></svg>
              </button>
            </div>
          </div>

          <div class="chat-main">
            <div id="chatMessages" class="chat-messages">
              <p class="empty">No hay chat seleccionado.</p>
            </div>

            <div class="chat-input">
              <div class="chat-input-bar">
                <textarea id="chatMessageInput" rows="1" placeholder="Escribe un mensaje"></textarea>
                <button type="button" class="chat-send-btn" id="sendMessageBtn" aria-label="Enviar">
                  <svg viewBox="0 0 24 24" fill="none"><path d="M5 12 19 5l-3 14-4-5-4 3z" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
              </div>
              <p class="hint" id="chatSubtitle"></p>
            </div>
          </div>
        </div>
      </section>

      <!-- MANUAL -->
      <section id="view-manual" class="view-panel">
        <div class="view-header"><div class="view-left"></div><div class="view-title">Cifrado manual</div><div class="view-right"></div></div>
        <div class="card manual-card">
          <div class="field">
            <label for="manualPassword">Contraseña</label>
            <div class="password-wrapper">
              <input id="manualPassword" type="password" autocomplete="off" />
              <button type="button" class="password-toggle-btn" id="manualPasswordToggle" aria-label="Mostrar u ocultar contraseña">
                <svg viewBox="0 0 24 24" fill="none"><path d="M3 12s2.5-5 9-5 9 5 9 5-2.5 5-9 5-9-5-9-5z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><circle cx="12" cy="12" r="2.5" stroke="currentColor" stroke-width="1.6"/></svg>
              </button>
            </div>
          </div>

          <div class="field">
            <label for="manualPlain">Texto en claro</label>
            <textarea id="manualPlain" rows="3" placeholder="Escribe texto para cifrar"></textarea>
          </div>

          <div class="buttons-row">
            <button type="button" class="btn" id="manualEncryptBtn">Cifrar</button>
            <button type="button" class="btn secondary" id="manualClearBtn">Limpiar</button>
            <button type="button" class="btn secondary small" id="manualCopyPlainBtn">Copiar claro</button>
            <button type="button" class="btn secondary small" id="manualPastePlainBtn">Pegar claro</button>
          </div>

          <div class="manual-divider"></div>

          <div class="field">
            <label for="manualCipher">Texto cifrado</label>
            <textarea id="manualCipher" rows="3" placeholder="Aquí aparecerá el texto cifrado o pega uno para descifrar"></textarea>
          </div>

          <div class="buttons-row">
            <button type="button" class="btn secondary" id="manualDecryptBtn">Descifrar</button>
            <button type="button" class="btn secondary small" id="manualCopyBtn">Copiar cifrado</button>
            <button type="button" class="btn secondary small" id="manualPasteCipherBtn">Pegar cifrado</button>
          </div>

          <div id="manualStatus" class="status"></div>
        </div>
      </section>

      <!-- AJUSTES -->
      <section id="view-settings" class="view-panel">
        <div class="view-header"><div class="view-left"></div><div class="view-title">Ajustes</div><div class="view-right"></div></div>

        <!-- Apariencia -->
        <div class="settings-group">
          <div class="settings-row">
            <div class="settings-icon blue">
              <svg viewBox="0 0 24 24" fill="none"><path d="M12 4a1 1 0 0 1 .92.61A5.5 5.5 0 1 1 7.39 13 5.48 5.48 0 0 1 6 9.5 1 1 0 0 1 7.2 8.6 3.5 3.5 0 1 0 11.4 4.2 1 1 0 0 1 12 4z" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </div>
            <div class="settings-body">
              <div class="settings-title">Apariencia</div>
              <div class="settings-sub">Modo claro u oscuro</div>
              <div class="settings-actions">
                <button type="button" class="btn secondary" id="lightModeBtn">Modo claro</button>
                <button type="button" class="btn secondary" id="darkModeBtn">Modo oscuro</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Mi ID -->
        <div class="settings-group">
          <div class="settings-row">
            <div class="settings-icon gray">
              <svg viewBox="0 0 24 24" fill="none"><circle cx="12" cy="8" r="3" stroke="currentColor" stroke-width="1.6"/><path d="M6 18c1.2-2.2 3.2-3.5 6-3.5s4.8 1.3 6 3.5" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg>
            </div>
            <div class="settings-body">
              <div class="settings-title">Mi ID</div>
              <div class="settings-sub" id="userIdValue">Pendiente</div>
              <div class="settings-actions">
                <button type="button" class="btn secondary" id="copyUserIdBtn">Copiar ID</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Clave privada -->
        <div class="settings-group">
          <div class="settings-row">
            <div class="settings-icon orange">
              <svg viewBox="0 0 24 24" fill="none"><path d="M8 10V8a4 4 0 1 1 8 0v2" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><rect x="6" y="10" width="12" height="10" rx="2" stroke="currentColor" stroke-width="1.6"/></svg>
            </div>
            <div class="settings-body">
              <div class="settings-title">Clave privada</div>
              <div class="settings-sub" id="privateKeyStateText">Sin clave privada</div>
              <div class="settings-actions">
                <button type="button" class="btn secondary" id="privateSaveBtn">Definir / cambiar</button>
                <button type="button" class="btn secondary" id="privateUnlockBtn">Desbloquear</button>
                <button type="button" class="btn secondary" id="privateForgetBtn">Olvidar</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Claves compartidas -->
        <div class="settings-group">
          <div class="settings-row">
            <div class="settings-icon green">
              <svg viewBox="0 0 24 24" fill="none"><path d="M7 7h10v4H7z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><path d="M7 13h6v4H7z" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </div>
            <div class="settings-body">
              <div class="settings-title">Claves compartidas</div>
              <div class="settings-sub">Chats con sus claves guardadas cifradas</div>
            </div>
          </div>
          <div id="keysList" class="settings-status"></div>
        </div>

        <!-- Privacidad general -->
        <div class="settings-group">
          <div class="settings-row">
            <div class="settings-icon gray"></div>
            <div class="settings-body">
              <div class="settings-title">Privacidad general</div>
              <div class="settings-sub">Control local de datos y cifrado</div>
              <div class="settings-actions">
                <button type="button" class="btn secondary" id="clearChatsBtn">Borrar chats</button>
                <button type="button" class="btn secondary" id="clearAllBtn">Borrar todo</button>
              </div>
            </div>
          </div>
          <div class="settings-status">Se borra solo la información guardada en este dispositivo.</div>
        </div>
      </section>
    </main>

    <!-- Modal genérico mejorado -->
    <div id="modalOverlay" class="modal-overlay hidden">
      <div class="modal-card">
        <div class="modal-title" id="modalTitle"></div>
        <div class="modal-message" id="modalMessage"></div>

        <!-- Entrada de texto -->
        <div class="modal-input-wrapper" id="modalInputWrapper">
          <input id="modalInput" type="text" />
        </div>

        <!-- Lista de claves copiables -->
        <div class="modal-keys" id="modalKeysContainer"></div>

        <!-- Lista de opciones (botonera) -->
        <div class="modal-choice-list hidden" id="modalChoiceList"></div>

        <div class="modal-buttons" id="modalButtons">
          <button type="button" class="btn secondary" id="modalCancelBtn">Cancelar</button>
          <button type="button" class="btn" id="modalConfirmBtn">Aceptar</button>
        </div>
      </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="toast"></div>

    <!-- Navegación inferior -->
    <nav class="bottom-nav">
      <div class="bottom-nav-inner">
        <button class="nav-item" data-view="manual" type="button">
          <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none"><path d="M5 6h14M5 12h9M5 18h14" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
          <span class="nav-label">Manual</span>
        </button>

        <button class="nav-item active" data-view="chats" type="button">
          <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none"><path d="M5 5h14v10H10l-4 4z" stroke="currentColor" stroke-width="1.6" stroke-linejoin="round"/></svg></span>
          <span class="nav-label">Chats</span>
        </button>

        <button class="nav-item" data-view="settings" type="button">
          <span class="nav-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none"><path d="M12 9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z" stroke="currentColor" stroke-width="1.6"/><path d="M4 12h2m12 0h2M12 4v2m0 12v2m-5.3-11.3 1.4 1.4m7.8 7.8 1.4 1.4m-10.6 0 1.4-1.4m7.8-7.8 1.4-1.4" stroke="currentColor" stroke-width="1.6" stroke-linecap="round"/></svg></span>
          <span class="nav-label">Ajustes</span>
        </button>
      </div>
    </nav>
  </div>

  <script>
    const enc = new TextEncoder();
    const dec = new TextDecoder();

    const THEME_KEY = "cryptoChat_theme_v2";
    const STATE_KEY = "cryptoChat_state_v7";
    const KEYS_STATE_KEY = "cryptoChat_keys_state_v4";
    const PRIVATE_STATE_KEY = "cryptoChat_private_key_v1";
    const USER_ID_KEY = "cryptoChat_user_id_v1";

    let appState = { chats: [] };
    let keysState = { entries: {} }; // { [chatId]: { cipher, privCipher, unlocked } }
    let privateState = { cipher: null, unlocked: null };
    let currentChatId = null;
    let toastTimeout = null;
    let userId = null;

    let isEditMode = false;
    let selectedChatIds = new Set();
    let chatSearchTerm = "";

    function bufToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = "";
      for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }
    function base64ToBuf(base64) {
      const binary = atob(base64.trim());
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    }

    async function deriveKey(password, salt) {
      const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]);
      return crypto.subtle.deriveKey(
        { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt","decrypt"]
      );
    }
    async function encryptText(plainText, password) {
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc.encode(plainText));
      const out = new Uint8Array(salt.byteLength + iv.byteLength + encrypted.byteLength);
      out.set(salt, 0); out.set(iv, 16); out.set(new Uint8Array(encrypted), 28);
      return bufToBase64(out.buffer);
    }
    async function decryptText(cipherBase64, password) {
      const data = new Uint8Array(base64ToBuf(cipherBase64));
      if (data.byteLength < 29) throw new Error("Formato no válido");
      const salt = data.slice(0,16), iv = data.slice(16,28), ciphertext = data.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
      return dec.decode(decrypted);
    }

    function randomFromCharset(length, charset) {
      const bytes = crypto.getRandomValues(new Uint8Array(length));
      let out = "";
      for (let i = 0; i < length; i++) out += charset.charAt(bytes[i] % charset.length);
      return out;
    }
    function generateSharedKeySuggestion() {
      const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZñÑ";
      const digits = "0123456789";
      const specials = "!@#$%&*+-_=?.:,;";
      return randomFromCharset(24, letters + digits + specials);
    }
    function generateUserId() {
      const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      return randomFromCharset(12, chars);
    }
    function generateId() {
      const bytes = crypto.getRandomValues(new Uint8Array(16));
      return Array.from(bytes).map(b => b.toString(16).padStart(2,"0")).join("");
    }
    function formatTime(ts) {
      if (!ts) return "";
      const d = new Date(ts);
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }
    function getInitialLetter(name) { return (name || "?").trim().charAt(0).toUpperCase(); }

    /* Toast */
    function showToast(message, type) {
      const toast = document.getElementById("toast");
      toast.textContent = message;
      toast.className = "toast" + (type ? " " + type : "");
      toast.classList.add("visible");
      if (toastTimeout) clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => toast.classList.remove("visible"), 2000);
    }

    /* MODAL mejorado */
    function setupModal() {
      const overlay = document.getElementById("modalOverlay");
      const titleEl = document.getElementById("modalTitle");
      const messageEl = document.getElementById("modalMessage");
      const inputWrapper = document.getElementById("modalInputWrapper");
      const inputEl = document.getElementById("modalInput");
      const keysContainer = document.getElementById("modalKeysContainer");
      const choicesList = document.getElementById("modalChoiceList");
      const cancelBtn = document.getElementById("modalCancelBtn");
      const confirmBtn = document.getElementById("modalConfirmBtn");
      const buttons = document.getElementById("modalButtons");

      let modalResolve = null;
      let currentOptions = null;

      function clearKeys() { keysContainer.innerHTML = ""; }
      function clearChoices() { choicesList.innerHTML = ""; choicesList.classList.add("hidden"); }

      function closeModal(result) {
        overlay.classList.add("hidden");
        if (modalResolve) { modalResolve(result); modalResolve = null; }
        currentOptions = null;
        clearKeys(); clearChoices();
      }

      cancelBtn.addEventListener("click", () => closeModal(null));
      confirmBtn.addEventListener("click", () => {
        if (currentOptions && currentOptions.mode === "prompt") closeModal((inputEl.value || "").trim());
        else closeModal(true);
      });
      overlay.addEventListener("click", (e) => { if (e.target === overlay) closeModal(null); });
      document.addEventListener("keydown", (e) => {
        if (overlay.classList.contains("hidden")) return;
        if (e.key === "Escape") closeModal(null);
        else if (e.key === "Enter" && currentOptions && currentOptions.mode === "prompt") {
          e.preventDefault(); closeModal((inputEl.value || "").trim());
        }
      });

      function addKeyBlock(label, value) {
        const labelEl = document.createElement("div");
        labelEl.className = "modal-kv-label";
        labelEl.textContent = label;

        const wrap = document.createElement("div");
        wrap.className = "modal-key-wrapper";
        const text = document.createElement("div");
        text.className = "modal-key-text";
        text.textContent = value;

        const copy = document.createElement("button");
        copy.type = "button"; copy.className = "btn secondary small"; copy.textContent = "Copiar";
        copy.addEventListener("click", async () => {
          try { await navigator.clipboard.writeText(value); showToast("Copiado", "ok"); } catch { showToast("No se pudo copiar", "error"); }
        });

        wrap.appendChild(text); wrap.appendChild(copy);
        keysContainer.appendChild(labelEl); keysContainer.appendChild(wrap);
      }

      function addChoice(label, value) {
        const btn = document.createElement("button");
        btn.type = "button"; btn.className = "btn secondary"; btn.textContent = label;
        btn.addEventListener("click", () => closeModal({ choice: value }));
        choicesList.appendChild(btn);
        choicesList.classList.remove("hidden");
      }

      window.openModal = function(options) {
        currentOptions = options || {};
        return new Promise(resolve => {
          modalResolve = resolve;
          titleEl.textContent = options.title || "";
          messageEl.textContent = options.message || "";
          const mode = options.mode || "alert";
          inputWrapper.style.display = mode === "prompt" ? "block" : "none";
          buttons.style.display = options.choices ? "none" : "flex";
          if (mode === "prompt") {
            inputEl.type = options.password ? "password" : "text";
            inputEl.placeholder = options.placeholder || "";
            inputEl.value = options.defaultValue || "";
          }

          clearKeys(); clearChoices();
          if (options.keys && Array.isArray(options.keys)) {
            options.keys.forEach(k => addKeyBlock(k.label, k.value));
          } else if (options.copyText) {
            addKeyBlock("Dato", options.copyText);
          }
          if (options.choices && Array.isArray(options.choices)) {
            options.choices.forEach(c => addChoice(c.label, c.value));
          }

          overlay.classList.remove("hidden");
          setTimeout(() => { if (mode === "prompt") inputEl.focus(); }, 20);
        });
      };
    }
    async function askText(title, message, opts) {
      const res = await openModal({
        title, message, mode: "prompt",
        placeholder: opts && opts.placeholder,
        defaultValue: opts && opts.defaultValue,
        password: opts && opts.password
      });
      if (res == null) return null;
      const trimmed = String(res).trim();
      if (!trimmed) return "";
      return trimmed;
    }
    async function askConfirm(title, message, confirmText) {
      const res = await openModal({ title, message, mode: "alert" });
      return !!res;
    }
    async function askChoice(title, message, choices) {
      const res = await openModal({ title, message, choices });
      return res && res.choice ? res.choice : null;
    }

    /* Estado */
    function loadAppState() {
      try {
        const raw = localStorage.getItem(STATE_KEY);
        if (!raw) { appState = { chats: [] }; return; }
        const parsed = JSON.parse(raw);
        appState = {
          chats: (parsed.chats || []).map(chat => ({
            id: chat.id || generateId(),
            name: chat.name || "Chat",
            messages: Array.isArray(chat.messages) ? chat.messages.map(m => ({
              id: m.id || generateId(),
              fromMe: !!m.fromMe,
              cipher: m.cipher || "",
              timestamp: m.timestamp || Date.now(),
              priv: !!m.priv
            })) : [],
            lastPreview: chat.lastPreview || "",
            lastTimestamp: chat.lastTimestamp || null,
            locked: !!chat.locked,
            doubleLocked: !!chat.doubleLocked,      // chat completo con clave privada
            privateMine: !!chat.privateMine,        // solo mis mensajes con clave privada
            idToken: chat.idToken || null
          }))
        };
      } catch { appState = { chats: [] }; }
    }
    function saveAppState() {
      try { localStorage.setItem(STATE_KEY, JSON.stringify(appState)); } catch {}
    }

    function loadKeysState() {
      try {
        const raw = localStorage.getItem(KEYS_STATE_KEY);
        keysState = { entries: {} };
        if (!raw) return;
        const parsed = JSON.parse(raw) || {};
        Object.keys(parsed).forEach(chatId => {
          keysState.entries[chatId] = {
            cipher: parsed[chatId].cipher || null,
            privCipher: parsed[chatId].privCipher || null,
            unlocked: null
          };
        });
      } catch { keysState = { entries: {} }; }
    }
    function saveKeysState() {
      try {
        const out = {};
        Object.keys(keysState.entries).forEach(id => {
          const e = keysState.entries[id];
          out[id] = { cipher: e.cipher || null, privCipher: e.privCipher || null };
        });
        localStorage.setItem(KEYS_STATE_KEY, JSON.stringify(out));
      } catch {}
    }

    function loadPrivateState() {
      try {
        const raw = localStorage.getItem(PRIVATE_STATE_KEY);
        if (!raw) { privateState = { cipher: null, unlocked: null }; return; }
        const parsed = JSON.parse(raw);
        privateState = { cipher: parsed && parsed.cipher ? parsed.cipher : null, unlocked: null };
      } catch { privateState = { cipher: null, unlocked: null }; }
    }
    function savePrivateState() {
      try { localStorage.setItem(PRIVATE_STATE_KEY, JSON.stringify({ cipher: privateState.cipher || null })); } catch {}
    }

    function loadUserId() {
      try {
        const raw = localStorage.getItem(USER_ID_KEY);
        userId = raw || generateUserId();
        if (!raw) localStorage.setItem(USER_ID_KEY, userId);
      } catch { userId = generateUserId(); }
      const el = document.getElementById("userIdValue"); if (el) el.textContent = userId;
    }

    function getUnlockedKeyForChat(chatId) {
      const entry = keysState.entries[chatId];
      return entry && entry.unlocked ? entry.unlocked : null;
    }
    function getPrivateKeyUnlocked() { return privateState.unlocked || null; }
    function findChatById(id) { return (appState.chats || []).find(c => c.id === id) || null; }

    async function ensureSharedKeyUnlocked(chatId) {
      const entry = keysState.entries[chatId];
      if (!entry) return null;
      if (entry.unlocked) return entry.unlocked;

      // 1) Intentar con clave privada si hay protección
      if (entry.privCipher) {
        let pk = getPrivateKeyUnlocked();
        if (!pk && privateState.cipher) {
          const ok = await askConfirm("Clave privada", "Se necesita tu clave privada para ver esta clave.");
          if (!ok) return null;
          await unlockPrivateKey();
          pk = getPrivateKeyUnlocked();
        }
        if (pk) {
          try {
            const plain = await decryptText(entry.privCipher, pk);
            entry.unlocked = plain; saveKeysState(); return plain;
          } catch {}
        }
      }

      // 2) Pedir la original
      if (entry.cipher) {
        const key = await askText("Desbloquear clave", "Introduce la clave original del chat.", { password: true, placeholder: "Clave original" });
        if (key == null || key === "") return null;
        try {
          const plain = await decryptText(entry.cipher, key);
          entry.unlocked = plain; saveKeysState(); return plain;
        } catch { showToast("No se ha podido desbloquear la clave.", "error"); return null; }
      }
      return null;
    }

    async function updateLastPreviewForChat(chatId) {
      const chat = findChatById(chatId);
      if (!chat || !chat.messages || !chat.messages.length) {
        if (chat) { chat.lastPreview = ""; chat.lastTimestamp = null; saveAppState(); }
        return;
      }
      const last = chat.messages[chat.messages.length - 1];
      chat.lastTimestamp = last.timestamp || Date.now();

      if (chat.doubleLocked) { chat.lastPreview = "[privado]"; saveAppState(); return; }

      const sharedKey = getUnlockedKeyForChat(chat.id);
      if (!sharedKey) { chat.lastPreview = "[cifrado]"; saveAppState(); return; }

      try {
        let inner = last.cipher;
        if (chat.privateMine && last.fromMe && last.priv) {
          const pk = getPrivateKeyUnlocked();
          if (!pk) { chat.lastPreview = "[privado]"; saveAppState(); return; }
          inner = await decryptText(inner, pk);
        }
        const text = await decryptText(inner, sharedKey);
        chat.lastPreview = text.length > 60 ? text.slice(0,60) + "…" : text;
      } catch { chat.lastPreview = "[cifrado]"; }
      saveAppState();
    }

    /* Nav inferior visible/oculto */
    function setBottomNavVisible(visible) {
      const nav = document.querySelector(".bottom-nav");
      const app = document.querySelector(".app");
      if (visible) { nav.classList.remove("hidden"); app.classList.remove("chat-open"); }
      else { nav.classList.add("hidden"); app.classList.add("chat-open"); }
    }

    /* Render de chats y detalle */
    function renderChatList() {
      const container = document.getElementById("chatList");
      const titleLabel = document.getElementById("chatsTitleLabel");
      container.innerHTML = "";

      if (!appState.chats.length) {
        const p = document.createElement("p"); p.className = "empty"; p.textContent = "Sin chats todavía."; container.appendChild(p);
        if (titleLabel) titleLabel.textContent = "Chats"; return;
      }
      const chatsSorted = [...appState.chats].sort((a,b) => (b.lastTimestamp||0) - (a.lastTimestamp||0));
      const filtered = chatsSorted.filter(c => !chatSearchTerm || (c.name||"").toLowerCase().includes(chatSearchTerm));

      if (titleLabel) titleLabel.textContent = isEditMode && selectedChatIds.size > 0 ? "Seleccionados (" + selectedChatIds.size + ")" : "Chats";

      filtered.forEach(chat => {
        const key = getUnlockedKeyForChat(chat.id);
        const row = document.createElement("button");
        row.type = "button"; row.className = "chat-row" + (chat.id === currentChatId && !isEditMode ? " active" : "");
        row.dataset.chatId = chat.id;

        if (isEditMode) {
          const circle = document.createElement("div"); circle.className = "chat-select-circle";
          const inner = document.createElement("div"); inner.className = "chat-select-circle-inner";
          if (selectedChatIds.has(chat.id)) circle.classList.add("selected");
          circle.appendChild(inner); row.appendChild(circle);
        }

        const avatar = document.createElement("div"); avatar.className = "chat-avatar"; avatar.textContent = getInitialLetter(chat.name);
        const body = document.createElement("div"); body.className = "chat-row-body";
        const top = document.createElement("div"); top.className = "chat-row-top";
        const nameDiv = document.createElement("div"); nameDiv.className = "chat-row-name"; nameDiv.textContent = chat.name || "Chat";
        const timeDiv = document.createElement("div"); timeDiv.className = "chat-row-time"; timeDiv.textContent = chat.lastTimestamp ? formatTime(chat.lastTimestamp) : "";
        top.appendChild(nameDiv); top.appendChild(timeDiv);

        const bottom = document.createElement("div"); bottom.className = "chat-row-bottom";
        const previewDiv = document.createElement("div"); previewDiv.className = "chat-row-preview";
        previewDiv.textContent = chat.locked ? "Chat bloqueado" : (chat.lastPreview || "Sin mensajes");
        const badge = document.createElement("div"); badge.className = "chat-row-badge";
        badge.textContent = chat.locked ? "Bloqueado" : chat.doubleLocked ? "Privado" : key ? "Clave activa" : "Clave bloqueada";

        const lockBtn = document.createElement("button");
        lockBtn.type = "button"; lockBtn.className = "lock-toggle-btn" + (chat.locked ? " active" : "");
        lockBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none"><path d="M8 10V8a4 4 0 1 1 8 0v2" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><rect x="6" y="10" width="12" height="10" rx="2" stroke="currentColor" stroke-width="1.6"/></svg>`;
        lockBtn.addEventListener("click", (e) => { e.stopPropagation(); toggleChatLock(chat.id).catch(console.error); });

        const br = document.createElement("div"); br.className = "chat-row-right"; br.appendChild(badge); if (!isEditMode) br.appendChild(lockBtn);
        bottom.appendChild(previewDiv); bottom.appendChild(br);

        body.appendChild(top); body.appendChild(bottom);
        row.appendChild(avatar); row.appendChild(body);

        row.addEventListener("click", () => {
          if (isEditMode) { if (selectedChatIds.has(chat.id)) selectedChatIds.delete(chat.id); else selectedChatIds.add(chat.id); renderChatList(); }
          else { if (chat.locked) handleLockedChatClick(chat.id).catch(console.error); else selectChat(chat.id); }
        });

        container.appendChild(row);
      });
    }

    async function renderChatMessages() {
      const container = document.getElementById("chatMessages");
      const titleEl = document.getElementById("chatTitle");
      const subtitleEl = document.getElementById("chatSubtitle");
      container.innerHTML = "";
      const chat = findChatById(currentChatId);
      if (!chat) { titleEl.textContent = "Selecciona un chat"; subtitleEl.textContent = ""; container.innerHTML = `<p class="empty">No hay chat seleccionado.</p>`; return; }
      titleEl.textContent = chat.name || "Chat";

      if (chat.locked) { subtitleEl.textContent = "Chat bloqueado. Pulsa el candado en la lista para abrirlo."; container.innerHTML = `<p class="empty">Este chat está bloqueado.</p>`; return; }

      const sharedKey = getUnlockedKeyForChat(chat.id);
      const pk = getPrivateKeyUnlocked();

      if (chat.doubleLocked && !pk) {
        subtitleEl.textContent = "Chat cifrado con tu clave privada. Desbloquéala en Ajustes.";
        container.innerHTML = `<p class="empty">Este chat está bloqueado con tu clave privada.</p>`;
        return;
      }
      if (!chat.messages.length) {
        subtitleEl.textContent = sharedKey ? "Clave compartida activa." : "Configura la clave compartida en Ajustes.";
        container.innerHTML = `<p class="empty">Todavía no hay mensajes en este chat.</p>`;
        return;
      }

      // Subtítulo por estado
      if (chat.doubleLocked) subtitleEl.textContent = "Capa privada para todo el chat.";
      else if (chat.privateMine) subtitleEl.textContent = "Capa privada en tus mensajes. Los del otro se muestran con la clave compartida.";
      else subtitleEl.textContent = "Cifrado con clave compartida.";

      for (const msg of chat.messages) {
        const div = document.createElement("div");
        div.className = "message " + (msg.fromMe ? "me" : "other");
        let text = "[cifrado]";

        try {
          let inner = msg.cipher;

          if (chat.doubleLocked) {
            inner = await decryptText(inner, pk);
            text = await decryptText(inner, sharedKey);
          } else if (chat.privateMine && msg.fromMe && msg.priv) {
            if (!pk) {
              text = "[privado]"; // no hay pk desbloqueada
            } else {
              inner = await decryptText(inner, pk);
              text = await decryptText(inner, sharedKey);
            }
          } else {
            if (!sharedKey) text = "[cifrado]";
            else text = await decryptText(inner, sharedKey);
          }
        } catch { text = "[cifrado]"; }

        const textDiv = document.createElement("div");
        textDiv.className = "message-text";
        textDiv.textContent = text;

        const metaDiv = document.createElement("div");
        metaDiv.className = "message-meta";
        metaDiv.textContent = (msg.fromMe ? "Tú" : "Otro") + (msg.timestamp ? " · " + formatTime(msg.timestamp) : "");
        div.appendChild(textDiv); div.appendChild(metaDiv);

        div.addEventListener("click", async () => {
          try { await navigator.clipboard.writeText(msg.cipher); showToast("Texto cifrado copiado.", "ok"); } catch { showToast("No se ha podido copiar el cifrado.", "error"); }
        });

        container.appendChild(div);
      }
      container.scrollTop = container.scrollHeight;
    }

    function showChatList() {
      document.getElementById("chatsListContainer").classList.remove("hidden");
      document.getElementById("chatDetailContainer").classList.add("hidden");
      currentChatId = null;
      setBottomNavVisible(true);
      renderChatList();
    }
    function showChatDetail() {
      document.getElementById("chatsListContainer").classList.add("hidden");
      document.getElementById("chatDetailContainer").classList.remove("hidden");
      setBottomNavVisible(false);
    }
    function selectChat(chatId) { currentChatId = chatId; renderChatList(); showChatDetail(); renderChatMessages().catch(console.error); }

    /* Bloqueo por chat (lista) */
    async function toggleChatLock(chatId) {
      const chat = findChatById(chatId); if (!chat) return;
      if (!chat.locked) {
        const ok = await askConfirm("Bloquear chat", "Para abrirlo necesitarás su clave compartida."); if (!ok) return;
        chat.locked = true;
      } else {
        const ok = await askConfirm("Desbloquear chat", "Dejará de estar bloqueado en este dispositivo."); if (!ok) return;
        chat.locked = false;
      }
      saveAppState(); renderChatList(); if (currentChatId === chatId) renderChatMessages().catch(console.error);
    }
    async function handleLockedChatClick(chatId) {
      const chat = findChatById(chatId); if (!chat) return;
      const proceed = await askConfirm("Chat bloqueado", "Para abrir este chat se necesita su clave compartida.");
      if (!proceed) return;
      if (!keysState.entries[chatId]) keysState.entries[chatId] = { cipher: null, privCipher: null, unlocked: null };
      const key = await ensureSharedKeyUnlocked(chatId);
      if (!key) { showToast("No se ha podido desbloquear la clave del chat.", "error"); return; }
      chat.locked = false; saveAppState(); renderChatList(); selectChat(chatId);
    }

    /* Modos de cifrado privado */
    async function encryptAllWithPrivate(chat, pk) {
      if (!chat.messages.length) return;
      for (const msg of chat.messages) {
        if (!msg.priv) { const outer = await encryptText(msg.cipher, pk); msg.cipher = outer; msg.priv = true; }
      }
    }
    async function decryptAllPrivate(chat, pk) {
      if (!chat.messages.length) return;
      const out = [];
      for (const msg of chat.messages) {
        const inner = await decryptText(msg.cipher, pk);
        out.push(inner);
      }
      chat.messages.forEach((m,i) => { m.cipher = out[i]; m.priv = false; });
    }
    async function encryptMineWithPrivate(chat, pk) {
      for (const msg of chat.messages) {
        if (msg.fromMe && !msg.priv) { msg.cipher = await encryptText(msg.cipher, pk); msg.priv = true; }
      }
    }
    async function decryptMinePrivate(chat, pk) {
      const out = [];
      for (const msg of chat.messages) {
        if (msg.fromMe && msg.priv) out.push(await decryptText(msg.cipher, pk));
        else out.push(null);
      }
      chat.messages.forEach((m,i) => { if (m.fromMe && m.priv) { m.cipher = out[i]; m.priv = false; } });
    }

    async function handlePrivateMenu() {
      const chat = findChatById(currentChatId);
      if (!chat) { showToast("Selecciona un chat primero.", "error"); return; }
      const sharedKey = await ensureSharedKeyUnlocked(chat.id);
      if (!sharedKey) { showToast("Configura la clave compartida del chat en Ajustes.", "error"); return; }

      // Construir opciones según estado
      const choices = [];
      if (!chat.doubleLocked && !chat.privateMine) {
        choices.push({ label: "Cifrar el chat", value: "all_on" });
        choices.push({ label: "Cifrar mis mensajes", value: "mine_on" });
        choices.push({ label: "Cifrar el chat y mis mensajes", value: "both_on" });
      } else {
        if (chat.doubleLocked) choices.push({ label: "Descifrar el chat", value: "all_off" });
        if (chat.privateMine && !chat.doubleLocked) choices.push({ label: "Descifrar mis mensajes", value: "mine_off" });
        if (chat.doubleLocked && chat.privateMine) choices.push({ label: "Descifrar el chat (mantener mis mensajes privados)", value: "all_off_keep_mine" });
      }

      const opt = await askChoice("Opciones de cifrado", "Elige cómo aplicar tu clave privada en este chat:", choices);
      if (!opt) return;

      // Asegurar clave privada
      async function needPrivateKey() {
        let pk = getPrivateKeyUnlocked();
        if (!pk && privateState.cipher) await unlockPrivateKey();
        pk = getPrivateKeyUnlocked();
        if (!pk) {
          const k = await askText("Clave privada", "Introduce tu clave privada.", { password: true, placeholder: "Clave privada" });
          if (k == null || k === "") return null;
          privateState.unlocked = k; savePrivateState(); return k;
        }
        return pk;
      }

      if (opt === "all_on" || opt === "both_on") {
        const pk = await needPrivateKey(); if (!pk) { showToast("No se pudo usar la clave privada.", "error"); return; }
        await encryptAllWithPrivate(chat, pk);
        chat.doubleLocked = true;
        chat.privateMine = (opt === "both_on") ? true : false;
        saveAppState();
      } else if (opt === "mine_on") {
        const pk = await needPrivateKey(); if (!pk) { showToast("No se pudo usar la clave privada.", "error"); return; }
        if (chat.doubleLocked) { // venimos de todo cifrado -> descifra todo y aplica solo a mis mensajes
          await decryptAllPrivate(chat, pk);
        }
        await encryptMineWithPrivate(chat, pk);
        chat.doubleLocked = false;
        chat.privateMine = true;
        saveAppState();
      } else if (opt === "all_off") {
        const pk = await needPrivateKey(); if (!pk) return;
        await decryptAllPrivate(chat, pk);
        chat.doubleLocked = false;
        // No tocamos privateMine
        saveAppState();
      } else if (opt === "mine_off") {
        const pk = await needPrivateKey(); if (!pk) return;
        await decryptMinePrivate(chat, pk);
        chat.privateMine = false;
        saveAppState();
      } else if (opt === "all_off_keep_mine") {
        const pk = await needPrivateKey(); if (!pk) return;
        await decryptAllPrivate(chat, pk);
        await encryptMineWithPrivate(chat, pk);
        chat.doubleLocked = false;
        chat.privateMine = true;
        saveAppState();
      }

      await updateLastPreviewForChat(chat.id);
      renderChatList();
      await renderChatMessages();
      // Por seguridad, olvidamos la clave privada en memoria
      privateState.unlocked = null; savePrivateState(); renderPrivateKeyState();
    }

    /* Envío de mensaje */
    async function sendCurrentMessage() {
      const chat = findChatById(currentChatId);
      const textarea = document.getElementById("chatMessageInput");
      if (!chat || !textarea) return;
      const text = textarea.value.trim(); if (!text) return;

      let sharedKey = getUnlockedKeyForChat(chat.id);
      if (!sharedKey) sharedKey = await ensureSharedKeyUnlocked(chat.id);
      if (!sharedKey) { showToast("Clave compartida bloqueada. Configúrala en Ajustes.", "error"); return; }

      try {
        const innerCipher = await encryptText(text, sharedKey);
        let finalCipher = innerCipher;
        let willPriv = false;

        if (chat.doubleLocked) {
          const pk = getPrivateKeyUnlocked();
          if (!pk) { showToast("Desbloquea tu clave privada para enviar en este chat.", "error"); return; }
          finalCipher = await encryptText(innerCipher, pk);
          willPriv = true;
        } else if (chat.privateMine) {
          const pk = getPrivateKeyUnlocked();
          if (!pk) { showToast("Desbloquea tu clave privada para enviar privado.", "error"); return; }
          finalCipher = await encryptText(innerCipher, pk);
          willPriv = true;
        }

        if (!Array.isArray(chat.messages)) chat.messages = [];
        const now = Date.now();
        chat.messages.push({ id: generateId(), fromMe: true, cipher: finalCipher, timestamp: now, priv: willPriv });
        chat.lastPreview = text.length > 60 ? text.slice(0,60) + "…" : text;
        chat.lastTimestamp = now;

        saveAppState();
        textarea.value = "";
        renderChatList();
        await renderChatMessages();
        try { await navigator.clipboard.writeText(finalCipher); showToast("Mensaje cifrado copiado.", "ok"); } catch {}
      } catch { showToast("Error al cifrar el mensaje.", "error"); }
    }

    /* Gestión de claves compartidas + ID */
    async function setKeyForChat(chatId, key, storeCipher) {
      if (!keysState.entries[chatId]) keysState.entries[chatId] = { cipher: null, privCipher: null, unlocked: null };
      const entry = keysState.entries[chatId];
      entry.unlocked = key;

      if (storeCipher) {
        try { entry.cipher = await encryptText(key, key); } catch { showToast("No se pudo guardar la clave.", "error"); }
      }

      const chat = findChatById(chatId);
      if (chat && !chat.idToken) { try { chat.idToken = await encryptText(key, key); } catch {} saveAppState(); }

      // si hay clave privada desbloqueada, opcionalmente protegemos también
      if (privateState.unlocked) {
        try { entry.privCipher = await encryptText(key, privateState.unlocked); } catch {}
      }

      saveKeysState();
      await updateLastPreviewForChat(chatId);
      renderKeysList(); renderChatList(); renderChatMessages().catch(() => {});
    }

    async function configureKeyForChat(chatId, storeCipher) {
      const chat = findChatById(chatId); if (!chat) return;
      if (!keysState.entries[chatId]) keysState.entries[chatId] = { cipher: null, privCipher: null, unlocked: null };
      const entry = keysState.entries[chatId];
      if (entry.unlocked) { await setKeyForChat(chatId, entry.unlocked, storeCipher); return; }
      const key = await askText("Clave compartida", "Clave para " + (chat.name || "chat") + ".", { placeholder: "Clave", password: true });
      if (key == null || key === "") return;
      await setKeyForChat(chatId, key, storeCipher);
    }

    function renderKeysList() {
      const container = document.getElementById("keysList");
      container.innerHTML = "";
      if (!appState.chats.length) { container.textContent = "Sin chats para gestionar claves."; return; }

      const list = document.createElement("div");
      appState.chats.forEach(chat => {
        const entry = keysState.entries[chat.id] || (keysState.entries[chat.id] = { cipher: null, privCipher: null, unlocked: null });

        const row = document.createElement("div"); row.className = "settings-row";
        const icon = document.createElement("div"); icon.className = "settings-icon green";
        const body = document.createElement("div"); body.className = "settings-body";
        const title = document.createElement("div"); title.className = "settings-title"; title.textContent = chat.name || "Chat";

        const sub = document.createElement("div"); sub.className = "settings-sub";
        let stateText = "Sin clave";
        if (entry.cipher && entry.unlocked) stateText = "Guardada cifrada y activa";
        else if (entry.cipher) stateText = "Guardada cifrada";
        else if (!entry.cipher && entry.unlocked) stateText = "Solo en memoria";
        if (entry.privCipher) stateText += " · protegida con clave privada";
        sub.textContent = stateText;

        const actions = document.createElement("div"); actions.className = "settings-actions";

        const setBtn = document.createElement("button"); setBtn.type="button"; setBtn.className="btn secondary"; setBtn.textContent="Definir / cambiar";
        setBtn.addEventListener("click", () => { changeOrSetKeyForChat(chat.id).catch(console.error); });
        actions.appendChild(setBtn);

        if (entry.cipher) {
          const unlockBtn = document.createElement("button"); unlockBtn.type="button"; unlockBtn.className="btn secondary"; unlockBtn.textContent="Desbloquear";
          unlockBtn.addEventListener("click", () => { unlockStoredKeyForChat(chat.id).catch(console.error); });
          actions.appendChild(unlockBtn);
        }

        const viewBtn = document.createElement("button"); viewBtn.type="button"; viewBtn.className="btn secondary"; viewBtn.textContent="Ver clave";
        viewBtn.addEventListener("click", () => { viewSharedKey(chat.id).catch(console.error); });
        actions.appendChild(viewBtn);

        const protectBtn = document.createElement("button"); protectBtn.type="button"; protectBtn.className="btn secondary"; protectBtn.textContent= entry.privCipher ? "Quitar protección privada" : "Proteger con mi clave";
        protectBtn.addEventListener("click", () => { toggleProtectWithPrivate(chat.id).catch(console.error); });
        actions.appendChild(protectBtn);

        const forgetBtn = document.createElement("button"); forgetBtn.type="button"; forgetBtn.className="btn secondary"; forgetBtn.textContent="Olvidar";
        forgetBtn.addEventListener("click", () => { forgetKeyForChat(chat.id); });
        actions.appendChild(forgetBtn);

        body.appendChild(title); body.appendChild(sub); body.appendChild(actions);
        row.appendChild(icon); row.appendChild(body); list.appendChild(row);
      });
      container.appendChild(list);
    }

    async function changeOrSetKeyForChat(chatId) {
      const chat = findChatById(chatId); if (!chat) return;
      const entry = keysState.entries[chatId] || (keysState.entries[chatId] = { cipher: null, privCipher: null, unlocked: null });

      if (!entry.cipher) { await configureKeyForChat(chatId, true); return; }

      const oldKey = await askText("Cambiar clave", "Introduce la clave actual del chat.", { password: true, placeholder: "Clave actual" });
      if (oldKey == null || oldKey === "") return;
      try { await decryptText(entry.cipher, oldKey); } catch { showToast("Clave actual incorrecta.", "error"); return; }

      const newKey = await askText("Nueva clave", "Introduce la nueva clave.", { password: true, placeholder: "Nueva clave" });
      if (newKey == null || newKey === "") return;

      const chatObj = findChatById(chatId);
      // Re-cifrar mensajes según estado
      if (chatObj.doubleLocked) {
        const pk = getPrivateKeyUnlocked() || await askText("Clave privada", "Introduce tu clave privada para recifrar.", { password: true });
        if (!pk) return;
        const nc = [];
        for (const m of chatObj.messages) {
          const inner = await decryptText(m.cipher, pk);
          const plain = await decryptText(inner, oldKey);
          const newInner = await encryptText(plain, newKey);
          const newOuter = await encryptText(newInner, pk);
          nc.push(newOuter);
        }
        chatObj.messages.forEach((m,i) => m.cipher = nc[i]);
      } else {
        const nc = [];
        for (const m of chatObj.messages) {
          let innerPlain;
          if (chatObj.privateMine && m.fromMe && m.priv) {
            const pk = getPrivateKeyUnlocked() || await askText("Clave privada", "Introduce tu clave privada para recifrar.", { password: true });
            if (!pk) return;
            const inner = await decryptText(m.cipher, pk);
            innerPlain = await decryptText(inner, oldKey);
            const newIn = await encryptText(innerPlain, newKey);
            m.cipher = await encryptText(newIn, pk);
            continue;
          } else {
            innerPlain = await decryptText(m.cipher, oldKey);
            nc.push(await encryptText(innerPlain, newKey));
          }
        }
        // aplicar nc a los mensajes no privados
        let j = 0;
        for (const m of chatObj.messages) {
          if (!(chatObj.privateMine && m.fromMe && m.priv)) { m.cipher = nc[j++]; }
        }
      }

      entry.unlocked = newKey;
      entry.cipher = await encryptText(newKey, newKey);
      if (privateState.unlocked) entry.privCipher = await encryptText(newKey, privateState.unlocked);
      saveKeysState(); saveAppState();
      await updateLastPreviewForChat(chatId);
      renderKeysList(); renderChatList(); renderChatMessages().catch(()=>{});
      showToast("Clave actualizada.", "ok");
    }

    async function unlockStoredKeyForChat(chatId) {
      const entry = keysState.entries[chatId]; if (!entry || !entry.cipher) return;
      const key = await askText("Desbloquear clave", "Introduce la clave original.", { password: true, placeholder: "Clave" });
      if (key == null || key === "") return;
      try {
        const plain = await decryptText(entry.cipher, key);
        entry.unlocked = plain; saveKeysState();
        await updateLastPreviewForChat(chatId); renderKeysList(); renderChatList(); renderChatMessages().catch(()=>{});
      } catch { showToast("No se ha podido desbloquear.", "error"); }
    }

    function forgetKeyForChat(chatId) {
      if (!keysState.entries[chatId]) keysState.entries[chatId] = { cipher: null, privCipher: null, unlocked: null };
      keysState.entries[chatId].cipher = null;
      keysState.entries[chatId].privCipher = null;
      keysState.entries[chatId].unlocked = null;
      saveKeysState(); renderKeysList(); renderChatList(); renderChatMessages().catch(()=>{});
    }

    async function viewSharedKey(chatId) {
      const k = await ensureSharedKeyUnlocked(chatId);
      if (!k) return;
      await openModal({
        title: "Clave compartida",
        message: "Esta clave se muestra solo en este dispositivo.",
        keys: [{ label: "Clave", value: k }]
      });
    }

    async function toggleProtectWithPrivate(chatId) {
      const entry = keysState.entries[chatId] || (keysState.entries[chatId] = { cipher: null, privCipher: null, unlocked: null });
      if (entry.privCipher) {
        const ok = await askConfirm("Quitar protección", "La clave dejará de estar protegida con tu clave privada.");
        if (!ok) return;
        entry.privCipher = null; saveKeysState(); renderKeysList(); return;
      }
      // Proteger
      let keyPlain = entry.unlocked;
      if (!keyPlain && entry.cipher) {
        const k = await askText("Clave original", "Introduce la clave del chat para protegerla con tu clave privada.", { password: true });
        if (k == null || k === "") return;
        try { keyPlain = await decryptText(entry.cipher, k); } catch { showToast("Clave incorrecta.", "error"); return; }
      }
      if (!keyPlain) {
        keyPlain = await askText("Clave compartida", "No hay clave guardada. Escríbela para protegerla.", { password: true });
        if (keyPlain == null || keyPlain === "") return;
      }
      let pk = getPrivateKeyUnlocked();
      if (!pk && privateState.cipher) await unlockPrivateKey();
      pk = getPrivateKeyUnlocked();
      if (!pk) {
        pk = await askText("Clave privada", "Introduce tu clave privada para proteger la clave del chat.", { password: true });
        if (pk == null || pk === "") return;
        privateState.unlocked = pk; savePrivateState(); renderPrivateKeyState();
      }
      entry.privCipher = await encryptText(keyPlain, pk);
      saveKeysState(); renderKeysList();
      privateState.unlocked = null; savePrivateState(); renderPrivateKeyState();
    }

    /* Unirse a chat */
    async function joinChatFlow() {
      const idCipher = await askText("Unirse a chat", "Pega el ID cifrado del chat compartido.", { placeholder: "ID cifrado" });
      if (idCipher == null || idCipher === "") return;
      const sharedKey = await askText("Clave compartida", "Introduce la clave compartida de este chat.", { placeholder: "Clave compartida", password: true });
      if (sharedKey == null || sharedKey === "") return;

      try { const plain = await decryptText(idCipher, sharedKey); if (plain !== sharedKey) throw new Error("mismatch"); }
      catch { showToast("ID o clave incorrectos.", "error"); return; }

      const name = await askText("Nombre del chat", "Nombre con el que verás este chat.", { placeholder: "Nombre del chat" });
      if (name == null || name === "") return;

      const chat = { id: generateId(), name, messages: [], lastPreview: "", lastTimestamp: null, locked: false, doubleLocked: false, privateMine: false, idToken: idCipher };
      appState.chats.push(chat); saveAppState();
      await setKeyForChat(chat.id, sharedKey, true);

      await openModal({
        title: "Chat unido",
        message: "Comparte estos datos con la otra persona solo por un canal seguro.",
        keys: [{ label: "ID cifrado", value: idCipher }, { label: "Clave compartida", value: sharedKey }]
      });

      renderChatList(); selectChat(chat.id); renderKeysList();
    }

    /* Clave privada */
    function renderPrivateKeyState() {
      const el = document.getElementById("privateKeyStateText");
      let text = "Sin clave privada";
      if (privateState.cipher && privateState.unlocked) text = "Guardada cifrada y activa";
      else if (privateState.cipher) text = "Guardada cifrada";
      else if (!privateState.cipher && privateState.unlocked) text = "Solo en memoria";
      el.textContent = text;
    }
    async function configurePrivateKey(storeCipher) {
      const key = await askText("Clave privada", "Introduce tu clave privada. Se guardará cifrada en este dispositivo.", { placeholder: "Clave privada", password: true });
      if (key == null || key === "") return;
      privateState.unlocked = key;
      if (storeCipher) { try { privateState.cipher = await encryptText(key, key); } catch { showToast("No se pudo guardar la clave privada.", "error"); } }
      savePrivateState(); renderPrivateKeyState(); renderChatMessages().catch(()=>{});
    }
    async function changeOrSetPrivateKey() {
      if (!privateState.cipher) { await configurePrivateKey(true); return; }
      const current = await askText("Cambiar clave privada", "Introduce tu clave privada actual.", { password: true });
      if (current == null || current === "") return;
      try { await decryptText(privateState.cipher, current); } catch { showToast("Clave privada actual incorrecta.", "error"); return; }
      const next = await askText("Nueva clave privada", "Introduce la nueva clave privada.", { password: true });
      if (next == null || next === "") return;

      // reenvolver mensajes que lleven capa privada
      for (const chat of appState.chats) {
        if (!chat.messages.length) continue;
        const out = [];
        for (const msg of chat.messages) {
          if (chat.doubleLocked || (chat.privateMine && msg.fromMe && msg.priv)) {
            const inner = await decryptText(msg.cipher, current);
            out.push(await encryptText(inner, next));
          } else out.push(null);
        }
        chat.messages.forEach((m,i) => { if (out[i]) m.cipher = out[i]; });
      }
      privateState.unlocked = next;
      privateState.cipher = await encryptText(next, next);
      savePrivateState(); saveAppState(); renderPrivateKeyState(); renderChatList(); renderChatMessages().catch(()=>{});
      showToast("Clave privada actualizada.", "ok");
    }
    async function unlockPrivateKey() {
      if (!privateState.cipher) { showToast("No hay clave privada guardada.", "error"); return; }
      const key = await askText("Desbloquear clave privada", "Introduce tu clave privada.", { password: true });
      if (key == null || key === "") return;
      try { privateState.unlocked = await decryptText(privateState.cipher, key); savePrivateState(); renderPrivateKeyState(); renderChatMessages().catch(()=>{}); }
      catch { showToast("No se ha podido desbloquear la clave privada.", "error"); }
    }
    function forgetPrivateKey() { privateState = { cipher: null, unlocked: null }; savePrivateState(); renderPrivateKeyState(); renderChatMessages().catch(()=>{}); }

    /* Borrados */
    async function clearChats() {
      const ok = await askConfirm("Borrar chats", "Se borrarán todos los chats locales."); if (!ok) return;
      appState = { chats: [] }; saveAppState(); renderChatList(); showChatList(); renderChatMessages().catch(()=>{}); renderKeysList();
    }
    async function clearAll() {
      const ok = await askConfirm("Borrar todo", "Se borrarán chats y claves de este dispositivo."); if (!ok) return;
      appState = { chats: [] }; keysState = { entries: {} }; privateState = { cipher: null, unlocked: null };
      localStorage.removeItem(STATE_KEY); localStorage.removeItem(KEYS_STATE_KEY); localStorage.removeItem(PRIVATE_STATE_KEY);
      renderChatList(); showChatList(); renderChatMessages().catch(()=>{}); renderKeysList(); renderPrivateKeyState();
    }

    /* Tema */
    function applyTheme(theme) {
      if (theme === "dark") document.body.classList.add("dark"); else document.body.classList.remove("dark");
      localStorage.setItem(THEME_KEY, theme);
    }
    function initTheme() { const stored = localStorage.getItem(THEME_KEY); applyTheme(stored === "dark" ? "dark" : "light"); }

    /* Navegación */
    function setupNavigation() {
      const navItems = document.querySelectorAll(".nav-item");
      const panels = document.querySelectorAll(".view-panel");
      function activate(view) {
        navItems.forEach(i => i.classList.toggle("active", i.getAttribute("data-view") === view));
        panels.forEach(p => p.classList.toggle("active", p.id === "view-" + view));
        if (view === "chats") showChatList(); else setBottomNavVisible(true);
      }
      navItems.forEach(i => i.addEventListener("click", () => activate(i.getAttribute("data-view"))));
    }

    /* Manual */
    function setupManual() {
      const pwdInput = document.getElementById("manualPassword");
      const plainArea = document.getElementById("manualPlain");
      const cipherArea = document.getElementById("manualCipher");
      const encryptBtn = document.getElementById("manualEncryptBtn");
      const decryptBtn = document.getElementById("manualDecryptBtn");
      const clearBtn = document.getElementById("manualClearBtn");
      const copyBtn = document.getElementById("manualCopyBtn");
      const pasteCipherBtn = document.getElementById("manualPasteCipherBtn");
      const copyPlainBtn = document.getElementById("manualCopyPlainBtn");
      const pastePlainBtn = document.getElementById("manualPastePlainBtn");
      const statusEl = document.getElementById("manualStatus");
      const pwdToggle = document.getElementById("manualPasswordToggle");

      function setStatus(t, type) { statusEl.textContent = t || ""; statusEl.className = "status" + (type ? " " + type : ""); }
      pwdToggle.addEventListener("click", () => { pwdInput.type = pwdInput.type === "password" ? "text" : "password"; });

      encryptBtn.addEventListener("click", async () => {
        const pwd = pwdInput.value; const plain = plainArea.value;
        if (!pwd) return setStatus("Escribe una contraseña para cifrar.", "error");
        if (!plain.trim()) return setStatus("Escribe texto en claro para cifrar.", "error");
        try { cipherArea.value = await encryptText(plain, pwd); setStatus("Texto cifrado listo para copiar.", "ok"); } catch { setStatus("Error al cifrar.", "error"); }
      });
      decryptBtn.addEventListener("click", async () => {
        const pwd = pwdInput.value; const cipher = cipherArea.value;
        if (!pwd) return setStatus("Escribe la contraseña para descifrar.", "error");
        if (!cipher.trim()) return setStatus("Pega texto cifrado para descifrar.", "error");
        try { plainArea.value = await decryptText(cipher, pwd); setStatus("Texto descifrado.", "ok"); } catch { setStatus("No se ha podido descifrar. ¿Contraseña correcta?", "error"); }
      });
      clearBtn.addEventListener("click", () => { plainArea.value = ""; cipherArea.value = ""; setStatus("", ""); });
      copyBtn.addEventListener("click", async () => { const v = cipherArea.value.trim(); if (!v) return setStatus("No hay nada que copiar.", "error"); try { await navigator.clipboard.writeText(v); setStatus("Texto cifrado copiado.", "ok"); } catch { setStatus("No se ha podido copiar.", "error"); } });
      pasteCipherBtn.addEventListener("click", async () => { try { cipherArea.value = await navigator.clipboard.readText(); setStatus("Texto pegado en cifrado.", "ok"); } catch { setStatus("No se ha podido pegar.", "error"); } });
      copyPlainBtn.addEventListener("click", async () => { const v = plainArea.value.trim(); if (!v) return setStatus("No hay texto en claro que copiar.", "error"); try { await navigator.clipboard.writeText(v); setStatus("Texto en claro copiado.", "ok"); } catch { setStatus("No se ha podido copiar.", "error"); } });
      pastePlainBtn.addEventListener("click", async () => { try { plainArea.value = await navigator.clipboard.readText(); setStatus("Texto pegado en claro.", "ok"); } catch { setStatus("No se ha podido pegar.", "error"); } });
    }

    /* Ajustes */
    function setupSettings() {
      document.getElementById("lightModeBtn").addEventListener("click", () => applyTheme("light"));
      document.getElementById("darkModeBtn").addEventListener("click", () => applyTheme("dark"));
      document.getElementById("clearChatsBtn").addEventListener("click", () => clearChats().catch(console.error));
      document.getElementById("clearAllBtn").addEventListener("click", () => clearAll().catch(console.error));
      document.getElementById("privateSaveBtn").addEventListener("click", () => changeOrSetPrivateKey().catch(console.error));
      document.getElementById("privateUnlockBtn").addEventListener("click", () => unlockPrivateKey().catch(console.error));
      document.getElementById("privateForgetBtn").addEventListener("click", () => forgetPrivateKey());
      document.getElementById("copyUserIdBtn").addEventListener("click", async () => { try { await navigator.clipboard.writeText(userId); showToast("ID copiado.", "ok"); } catch { showToast("No se ha podido copiar el ID.", "error"); } });
    }

    /* Editar chats */
    function setEditMode(enabled) {
      isEditMode = enabled;
      const editBtn = document.getElementById("chatsEditBtn");
      const searchBtn = document.getElementById("chatsSearchBtn");
      const newChatBtn = document.getElementById("newChatBtn");
      const joinChatBtn = document.getElementById("joinChatBtn");
      const delBtn = document.getElementById("chatsDeleteSelectedBtn");
      const encBtn = document.getElementById("chatsEncryptSelectedBtn");
      if (!enabled) selectedChatIds.clear();
      editBtn.textContent = enabled ? "Listo" : "Editar";
      searchBtn.classList.toggle("hidden", enabled);
      newChatBtn.classList.toggle("hidden", enabled);
      joinChatBtn.classList.toggle("hidden", enabled);
      delBtn.classList.toggle("hidden", !enabled);
      encBtn.classList.toggle("hidden", !enabled);
      renderChatList();
    }
    async function deleteSelectedChats() {
      if (!selectedChatIds.size) return;
      const ok = await askConfirm("Eliminar chats", "Se eliminarán " + selectedChatIds.size + " chats seleccionados."); if (!ok) return;
      appState.chats = appState.chats.filter(c => !selectedChatIds.has(c.id));
      selectedChatIds.forEach(id => delete keysState.entries[id]);
      selectedChatIds.clear(); saveAppState(); saveKeysState(); setEditMode(false); showChatList(); renderKeysList();
    }
    async function lockSelectedChats() {
      if (!selectedChatIds.size) return;
      const ok = await askConfirm("Bloquear chats", "Se bloquearán " + selectedChatIds.size + " chats en este dispositivo."); if (!ok) return;
      for (const c of appState.chats) if (selectedChatIds.has(c.id)) c.locked = true;
      saveAppState(); selectedChatIds.clear(); setEditMode(false); renderChatList();
    }

    function lockAllSessionKeys() {
      Object.values(keysState.entries).forEach(e => e.unlocked = null);
      privateState.unlocked = null; savePrivateState();
      renderPrivateKeyState(); renderChatList(); renderChatMessages().catch(()=>{});
    }

    /* UI de chats */
    function setupChatsUI() {
      const newChatBtn = document.getElementById("newChatBtn");
      const joinChatBtn = document.getElementById("joinChatBtn");
      const sendMessageBtn = document.getElementById("sendMessageBtn");
      const chatMessageInput = document.getElementById("chatMessageInput");
      const chatBackBtn = document.getElementById("chatBackBtn");
      const chatMenuBtn = document.getElementById("chatMenuBtn");
      const chatsEditBtn = document.getElementById("chatsEditBtn");
      const chatsDeleteBtn = document.getElementById("chatsDeleteSelectedBtn");
      const chatsEncryptBtn = document.getElementById("chatsEncryptSelectedBtn");
      const chatSearchInput = document.getElementById("chatSearchInput");
      const chatsSearchBtn = document.getElementById("chatsSearchBtn");

      newChatBtn.addEventListener("click", async () => {
        const name = await askText("Nuevo chat", "Nombre del chat o contacto.", { placeholder: "Nombre del chat" });
        if (name == null || name === "") return;

        const chat = { id: generateId(), name, messages: [], lastPreview: "", lastTimestamp: null, locked: false, doubleLocked: false, privateMine: false, idToken: null };
        appState.chats.push(chat); saveAppState();

        const suggestion = generateSharedKeySuggestion();
        const keyInput = await askText("Clave compartida", "Se sugiere usar esta clave generada aleatoriamente. Puedes usarla tal cual o modificarla.", { defaultValue: suggestion });
        const finalKey = (keyInput != null && keyInput !== "") ? keyInput : suggestion;
        await setKeyForChat(chat.id, finalKey, true);

        const updatedChat = findChatById(chat.id);
        const idToken = updatedChat && updatedChat.idToken ? updatedChat.idToken : "(no disponible)";

        await openModal({
          title: "Datos del chat",
          message: "Guárdalos en un lugar seguro.",
          keys: [
            { label: "Clave compartida", value: finalKey },
            { label: "ID cifrado (para unirse desde otro dispositivo)", value: idToken }
          ]
        });

        renderChatList(); selectChat(chat.id); renderKeysList();
      });

      joinChatBtn.addEventListener("click", () => joinChatFlow().catch(console.error));
      sendMessageBtn.addEventListener("click", () => sendCurrentMessage().catch(console.error));

      chatMessageInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendCurrentMessage().catch(console.error); }
      });
      chatMessageInput.addEventListener("input", () => {
        chatMessageInput.style.height = "auto";
        chatMessageInput.style.height = Math.min(chatMessageInput.scrollHeight, 90) + "px";
      });

      chatBackBtn.addEventListener("click", () => showChatList());
      chatMenuBtn.addEventListener("click", () => handlePrivateMenu().catch(console.error));

      chatsEditBtn.addEventListener("click", () => setEditMode(!isEditMode));
      chatsDeleteBtn.addEventListener("click", () => deleteSelectedChats().catch(console.error));
      chatsEncryptBtn.addEventListener("click", () => lockSelectedChats().catch(console.error));

      chatSearchInput.addEventListener("input", () => { chatSearchTerm = chatSearchInput.value.trim().toLowerCase(); renderChatList(); });
      chatsSearchBtn.addEventListener("click", () => chatSearchInput.focus());
    }

    document.addEventListener("DOMContentLoaded", () => {
      setupModal();
      initTheme(); setupNavigation(); setupManual(); setupSettings();
      loadAppState(); loadKeysState(); loadPrivateState(); loadUserId(); renderPrivateKeyState();
      setupChatsUI();
      renderChatList(); renderChatMessages().catch(()=>{}); renderKeysList();

      // Seguridad: al salir bloquear claves en memoria
      window.addEventListener("blur", lockAllSessionKeys);
      document.addEventListener("visibilitychange", () => { if (document.hidden) lockAllSessionKeys(); });
    });
  </script>
</body>
</html>
